// Generated by state_enforcer (https://github.com/petrs/state_enforcer)
package applet;

import javacard.framework.CardRuntimeException;

public class StateModel {

    public static final short SW_FUNCTINNOTALLOWED                      = (short) 0x9AF0;
    public static final short SW_UNKNOWNSTATE                           = (short) 0x9AF1;
    public static final short SW_UNKNOWNFUNCTION                        = (short) 0x9AF2;
    public static final short SW_INCORRECTSTATETRANSITION               = (short) 0x9AF3;


    // States constants
    public static final short STATE_UNSPECIFIED                         = (short) 0xF0F0;
    public static final short KEY_AES_1_PART_SEND                       = (short) 0xB6C7; // 1011011011000111
    public static final short KEY_AES_2_PARTS_SEND                      = (short) 0x2581; // 0010010110000001
    public static final short KEY_RSA_0_PARTS_RECEIVED                  = (short) 0xDB48; // 1101101101001000
    public static final short KEY_RSA_1_PARTS_RECEIVED                  = (short) 0x03C5; // 0000001111000101
    public static final short KEY_RSA_2_PARTS_RECEIVED                  = (short) 0x2942; // 0010100101000010
    public static final short KEY_RSA_WHOLE_ESTABLISHED                 = (short) 0xC234; // 1100001000110100
    public static final short STATE_APPLET_UPLOADED                     = (short) 0x546E; // 0101010001101110
    public static final short STATE_CARD_BLOCKED                        = (short) 0x4379; // 0100001101111001
    public static final short STATE_KEYS_GENERATED                      = (short) 0x8E75; // 1000111001110101
    public static final short STATE_SECURE_CHANNEL_ESTABLISHED          = (short) 0xCADB; // 1100101011011011
    public static final short STATE_SECURE_RESPONSE_SEND                = (short) 0xB2BE; // 1011001010111110

    // Functions constants
    public static final short FNC_block                                 = (short) 0x0AAB; // 0000101010101011
    public static final short FNC_deselect                              = (short) 0x1556; // 0001010101010110
    public static final short FNC_getSecretValue                        = (short) 0x2001; // 0010000000000001
    public static final short FNC_initSecureChannelKeys                 = (short) 0x2AAC; // 0010101010101100
    public static final short FNC_initializeKeys                        = (short) 0x3557; // 0011010101010111
    public static final short FNC_listSecrets                           = (short) 0x4002; // 0100000000000010
    public static final short FNC_sendKeyToClient                       = (short) 0x4AAD; // 0100101010101101
    public static final short FNC_sendState                             = (short) 0x5558; // 0101010101011000
    public static final short FNC_storeSecret                           = (short) 0x6003; // 0110000000000011
    public static final short FNC_updatePIN                             = (short) 0x6AAE; // 0110101010101110
    public static final short FNC_verifyPIN                             = (short) 0x7559; // 0111010101011001


    private short STATE_CURRENT = STATE_UNSPECIFIED;
    private short STATE_PREVIOUS = STATE_UNSPECIFIED;
    private short STATE_SECONDARY = STATE_UNSPECIFIED;

    public StateModel(short startState) {
        STATE_CURRENT = startState;
        STATE_PREVIOUS = startState;
    }

    public void checkAllowedFunction(short requestedFnc) {
        // Check allowed function in current state
        checkAllowedFunction(requestedFnc, STATE_CURRENT);
        // // Check secondary state (if required)
        checkAllowedFunctionSecondary(requestedFnc, STATE_SECONDARY);
    }

    public short changeState(short newState) {
        short prevState = STATE_CURRENT;
        STATE_CURRENT = changeState(STATE_CURRENT, newState);
        STATE_PREVIOUS = prevState;
        return STATE_CURRENT;
    }
    /** WARNING: this function forces new state despite the state model.**/
    public short forceChangeState(short newState) {
        STATE_PREVIOUS = STATE_CURRENT;
        STATE_CURRENT = newState;
        return STATE_CURRENT;
    }
    public short setSecondaryState(short newSecondaryState) {
        STATE_SECONDARY = newSecondaryState;
        return STATE_SECONDARY;
    }

    public short getState() {
        return STATE_CURRENT;
    }

    public short getSecondaryState() {
        return STATE_SECONDARY;
    }
    public short getPreviousState() {
        return STATE_PREVIOUS;
    }

    private static void checkAllowedFunction(short requestedFnc, short currentState) {
        // Check for functions which can be called from any state
        switch (requestedFnc) {
            // case FNC_someFunction:  return;    // enable if FNC_someFunction can be called from any state (typical for cleaning instructions)
            case FNC_block:  return;
            case FNC_sendState:  return;
        }

        // Check if function can be called from current state
        switch (currentState) {
            case STATE_APPLET_UPLOADED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_KEYS_GENERATED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                if (requestedFnc == FNC_initializeKeys) return;
                if (requestedFnc == FNC_sendKeyToClient) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_SECURE_CHANNEL_ESTABLISHED:
                if (requestedFnc == FNC_getSecretValue) return;
                if (requestedFnc == FNC_listSecrets) return;
                if (requestedFnc == FNC_storeSecret) return;
                if (requestedFnc == FNC_updatePIN) return;
                if (requestedFnc == FNC_verifyPIN) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_SECURE_RESPONSE_SEND:
                if (requestedFnc == FNC_deselect) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
        }
    }

    private static void checkAllowedFunctionSecondary(short requestedFnc, short currentSecondaryState) {
        // Check for functions which can be called from any state
        switch (requestedFnc) {
            // case FNC_someFunction:  return;    // enable if FNC_someFunction can be called from any state (typical for cleaning instructions)
            case FNC_block:  return;
            case FNC_sendState:  return;
        }

        // Check if function can be called from current state
        switch (currentSecondaryState) {
            case KEY_AES_1_PART_SEND:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                if (requestedFnc == FNC_sendKeyToClient) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case KEY_AES_2_PARTS_SEND:
                if (requestedFnc == FNC_getSecretValue) return;
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                if (requestedFnc == FNC_listSecrets) return;
                if (requestedFnc == FNC_storeSecret) return;
                if (requestedFnc == FNC_updatePIN) return;
                if (requestedFnc == FNC_verifyPIN) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case KEY_RSA_0_PARTS_RECEIVED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case KEY_RSA_1_PARTS_RECEIVED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case KEY_RSA_2_PARTS_RECEIVED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                if (requestedFnc == FNC_initializeKeys) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case KEY_RSA_WHOLE_ESTABLISHED:
                if (requestedFnc == FNC_initSecureChannelKeys) return;
                if (requestedFnc == FNC_sendKeyToClient) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
        }
    }

    private static short changeState(short currentState, short newState) {
        // Check for states which can be reached from any other state (typically some "cleaning" state)
        switch (newState) {
            //case STATE_ALWAYS_REACHABLE: return newState;
            case STATE_CARD_BLOCKED: return newState;
        }

        switch (currentState) {
            case STATE_APPLET_UPLOADED:
                if (newState == STATE_KEYS_GENERATED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_KEYS_GENERATED:
                if (newState == STATE_KEYS_GENERATED) return newState;
                if (newState == STATE_SECURE_CHANNEL_ESTABLISHED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_SECURE_CHANNEL_ESTABLISHED:
                if (newState == STATE_SECURE_RESPONSE_SEND) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_SECURE_RESPONSE_SEND:
                if (newState == STATE_APPLET_UPLOADED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
        }
        CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
        return newState;
    }

}
